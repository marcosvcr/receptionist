#ifndef EXPLOITATION_MATCHER_HPP
#define EXPLOITATION_MATCHER_HPP

#include <std_msgs/Int32.h>
#include <hbba_msgs/RegisterExploitationMatch.h>
#include <hbba_msgs/ExploitationMatch.h>
#include <hbba_msgs/Intention.h>
#include <std_msgs/String.h>
#include <ros/ros.h>
#include <boost/function.hpp>
#include <map>
#include <vector>
#include <string>

namespace iw
{
    /// \brief A sub-node that matches priority (int) values from arbitration
    /// modules to exploited desires.
    ///
    /// Exploitation matches are filtered with the latest intention output from
    /// the IW solver.
    ///  
    /// Topics specific to one arbitration module are registered in a private 
    /// namespace so that a full node can create more than one exploitation
    /// matcher and remap these namespaces appropriately. 
    ///
    /// To programmatically interact with an exploitation matcher, you can use
    /// the external callbacks from the public interface.
    ///
    /// Incoming topics:
    ///  - ~priority: A std_msgs/Int32 input, normally remapped to arbitration
    ///    output (see abtr_priority).
    ///  - intention: A hbba_msgs/Intention used to map exploited desire classes
    ///    to desire IDs.
    ///    This is the only non-private topic registration, since the intention
    ///    is normally global to all arbitration modules.
    ///
    /// Output topics:
    ///  - ~exploited_desire: A std_msgs/String message containing a desire id 
    ///    produced everytime an exploitation value is matched.
    ///
    /// Provided services:
    ///  - ~register: Register a int32/string[] pair.
    ///    A single priority can be matched to multiple desire classes in one
    ///    call.
    ///    Note that multiple priority values can be matched to a single desire
    ///    class, it's just registration that cannot be made in a single call.
    ///
    class ExploitationMatcher
    {
    public:
        typedef std::vector<std::string> StringVector;

        /// \brief Constructor.
        ///
        /// \param n Node handle for global topics.
        /// \param np Node handle for arbitration-specific topics.
        ExploitationMatcher(ros::NodeHandle& n, ros::NodeHandle& np);

        void intentionCB(const hbba_msgs::Intention::ConstPtr& msg);
        void priorityCB(const std_msgs::Int32::ConstPtr& msg);
        bool registerCB(hbba_msgs::RegisterExploitationMatch::Request& req,
            hbba_msgs::RegisterExploitationMatch::Response& rep);

        /// \brief Batch registration of exploitation match(es).
        ///
        /// See the definition of ExploitationMatch for details, mostly used by
        /// EventsGenerator.
        void registerMatches(const hbba_msgs::ExploitationMatch& match);
        void registerMatches(int priority, const StringVector& classes);

        /// \brief Callback registration for internal match events.
        ///
        /// Called at the same time as a desire match is published.
        template <class T>
        void registerMatchCB(void (T::*fun)(const std::string&), T* obj)
        {
            cb_ = boost::bind(fun, obj, _1);
        }

    private:
        ros::Subscriber sub_priority_;
        ros::Subscriber sub_intention_;
        ros::Publisher pub_desire_;
        ros::ServiceServer srv_register_;

        // The priority map can match more than one desire type per priority
        // value.
        typedef std::map<int, StringVector> PriorityMapType;
        PriorityMapType priority_map_;
        // The desires map can match more than one desire for each type.
        typedef std::map<std::string, StringVector> DesireMapType;
        DesireMapType desire_map_; 

        boost::function<void (const std::string&)> cb_;

        std::string topic_ns_;

    };
}

#endif

