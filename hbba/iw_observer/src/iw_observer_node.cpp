/// \file iw_observer_node.cpp Standalone IWObserver node with rules parser.
///

#include <iw_observer/runtime.hpp>
#include <iw_observer/rules_ast.hpp>
#include <ros/ros.h>
#include "rules_parser.hpp"

// Refers to the parser functions generated by Flex/Bison:
typedef struct yy_buffer_state* YY_BUFFER_STATE;

extern FILE*           yyin;
extern int             yyparse();
extern YY_BUFFER_STATE yy_scan_buffer(char *, size_t);
extern YY_BUFFER_STATE yy_scan_string(const char *);

int main(int argc, char** argv)
{
    using namespace iw_observer;

    ros::init(argc, argv, "iw_observer");
    
    ros::NodeHandle np("~");

    if (np.hasParam("ruleset")) {
        ROS_INFO("Parsing rules from 'ruleset' parameter...");
        std::string ruleset;
        np.getParam("ruleset", ruleset);
        if (ruleset.empty()) {
            ROS_INFO("Empty ruleset, ignoring and quitting.");
            return 0;
        }
        char* ruleset_str = const_cast<char*>(ruleset.c_str());
        yy_scan_string(ruleset.c_str());
        yyparse();
    } else if (argc >= 2) {
        ROS_INFO("Parsing rules from '%s' ...", argv[1]);
        yyin = fopen(argv[1], "ro");
        yyparse();
        fclose(yyin);
    } else {
        ROS_FATAL("iw_observer needs either the 'ruleset' parameter or a file "
                  "name as its first argument to parse its rules. Quitting.");
        return -1;
    }
    ROS_INFO("The ruleset contains %lu rule(s).", ruleset().size());
    Runtime node(ruleset());

    ros::spin();
}

